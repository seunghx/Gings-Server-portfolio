# Gings server portfolio

### GINGS CHAT
깅스 프로젝트에는 채팅 기능이 있었습니다. 처음에는 별다른 어려움 없이 개발이 가능할 것이라고 예상하였습니다. 그러나 추가로 고려해야 할 사항이 생겼습니다. 후에 웹 브라우저에서도 깅스 서비스가 제공되어야 했기 때문입니다.

(각 채팅방 목록과 그에 따른 메세지 이력이 클라이언트 내부 스토리지에 저장되는 상황에서)
클라이언트에 웹 브라우저가 추가될 경우 기존 모바일 앱과 브라우저 간, 그리고 브라우저와 또 다른 브라우저 간의 채팅방 목록의 이력과 수신 메세지 처리 관련 동기화가 필요하였습니다. 동기화가 되지 않으면 가령 사용자가 모바일 앱에서 로그아웃한 상태로 장시간 동안 브라우저로만 채팅하다가 나중에 모바일 앱에 로그인하였을 경우 모바일 앱에 보이는 채팅방 목록 및 메세지 이력이 사용자가 기대하는 이력과 다를 것입니다. 또는 브라우저에서는 읽음 처리된 메세지가 새로 로그인한 모바일 앱에서는 아직 읽음 처리되지 않았다고 표시될 수도 있을 것입니다.

동기화를 위해 채팅방마다 가장 최근에 서버로부터 받은 메세지를 가리키는 정보(이하 latestReceivedMessage)를 클라이언트와 서버에 각각 저장하기로 하였습니다. 클라이언트는 서버로부터 새 메세지를 받을 때마다 새 메세지가 추가된 채팅방의 latestReceivedMessage를 갱신한 후 서버에 전달하고 이를 전달받은 서버는 해당 채팅방에 대한 요청 사용자의 latestReceivedMessage 정보를 갱신합니다. 또한, 클라이언트는 서버와의 connection(매번의 로그인 후의 채팅을 위한 connection 및 네트워크 문제로 인한 reconnection)에 성공한 경우 각 채팅방의 latestReceivedMessage를 서버에 전달(이하 refresh 요청)하고 서버는 전달받은 latestReceivedMessage를 기반으로 추가로 전달해줘야 할 메세지 목록과 최신의 latestRecivedMessage 정보(위의 예의 경우 브라우저를 통해 갱신된 latestReceivedMessage)를 클라이언트에 응답함으로써 동기화가 가능하게 하였습니다. 이와 유사한 방법으로 추가 및 삭제된 채팅방 정보와 채팅방별로 추가 및 삭제된 유저 정보까지 refresh 요청에 대한 응답으로 클라이언트에 전달하여 동기화 가능하도록 하였습니다.

다음으로, 채팅방별로 사용자가 메세지를 어디까지 읽었는지에 대한 정보를 저장해야 했습니다. 간단한 방법은 각 메세지 별로 특정 사용자가 이를 읽었는지 아닌지에 대한 정보를 저장하는 방법이 있겠습니다. 그러나 이 방법의 경우 한 채팅방만 해도 사용자 수 * 메세지 수 만큼의 레코드가 데이터베이스에 저장되어야 하므로 좋지 않다고 판단하였습니다. 대신 채팅방마다 가장 마지막에 읽은 메세지를 가리키는 정보(이하 lastReadMessage)를 클라이언트와 서버에 각각 저장하기로 하였습니다. 사용자가 채팅방에 입장할 때 lastReadMessage는 latestReceivedMessage 값으로 갱신되어 서버에 전달되고 이를 전달받은 서버는 값을 갱신하여 후에 refresh 요청이 있을 때 다른 정보와 함께 갱신된 lastReadMessage를 전달합니다.


인터넷에 간단한 채팅 기능을 다루는 자료는 많았으나 보다 디테일한 상황까지 다루는 자료는 찾을 수 없었고 조언을 구할 멘토가 없어 어려움이 있었습니다. 기능을 축소하여 간단하게만 진행할까 생각도 했지만 하나의 기능을 구현하더라도 보다 완벽히 하고 싶었습니다. 완벽하진 않지만 위의 과정을 고민해보며 좋은 경험이 되었다고 생각합니다.

---

### 한계 
1. **메세지 확인 기능과 몇 명이 메세지를 확인했는지를 아직 구현못했다.**
 --> 현재 구현에서 위 기능을 추가하려면 고민해봐야할 것이 많다. 
 (네트워크 상황 등의 이유로 읽음 처리 메세지가 여러번 도착할 경우 등.)
 
2. **사용자가 어플리케이션에서 로그아웃하고 다른 계정으로 로그인해 채팅하는 경우를 고려하지 않았다는 점**
 (클라이언트 사이드에서 고민할 사항이긴 함)

3. **채팅방 유형(1:1, 그룹 채팅방)에 대한 처리(예 : 1:1 채팅의 경우 새로운 방이 생성되는 것을 방지해야함)를 위해 도메인을 변경할 필요가 있으며 기존 RDB를 그대로 사용하게 될 경우 필요시 채팅방 유형에 따라 테이블을 나눠야 할 수도 있으며(프로젝트 시간상 도메인 구조를 더 유연하게 변경하지는 못했다.) 채팅 메세지의 양이 엄청날 것이라는 점, 후에 서비스가 고도화 될 경우 메세지 타입도 여러가지가 될 것(스키마가 메세지 타입에 따라 다소 다를 수 있음)인데 이러한 점을 다 고려하였을 때 몽고DB와 같은 DOCUMENT 타입 NoSQL 사용이 더 좋았을 것이다. 메세지 타입과 채팅방 타입마다 RDB로 테이블을 나눠표현할 경우 채팅방 또는 메세지 목록을 취합하는 과정이 필요함. 메세지의 경우 시간 순에 맞게 정렬을하면 되므로 메세지 타입을 가리키는 슈퍼 클래스를 두고 이에 대한 리스트에서 시간 순에 맞게 정렬할 수는 있으나 그만큼 더 서버가 할일이 늘어나는셈 메세지를 저장할 때도 비교를 통해 메세지 타입에 따라 분기 시켜줘야함.**

---
## 채팅 API DOC
|프로토콜|ws|
|----|----|

---

### STOMP connect 요청 
|엔드포인트|설명|
| ------------ | ------------------ |
| /connect | Stomp connect end point |

#### 요청 STOMP header

|헤더명|값 설명|
|----|----|
|Authorization|Bearer tokenValue|

---
### 채팅방 외 클라이언트 요청
[채팅 관련 공지 채널 구독](https://github.com/seunghx/Gings-Server/wiki/%EC%B1%84%ED%8C%85-%EA%B3%B5%EC%A7%80-%EC%B1%84%EB%84%90-%EA%B5%AC%EB%8F%85)

[채팅방 생성](https://github.com/seunghx/Gings-Server/wiki/%EC%B1%84%ED%8C%85%EB%B0%A9-%EC%83%9D%EC%84%B1)

[채팅방 구독(입장)](https://github.com/seunghx/Gings-Server/wiki/%EC%B1%84%ED%8C%85%EB%B0%A9-%EA%B5%AC%EB%8F%85(%EC%9E%85%EC%9E%A5))

[리프레시 요청](https://github.com/seunghx/Gings-Server/wiki/%EC%B1%84%ED%8C%85%EB%B0%A9-%EB%AA%A9%EB%A1%9D-%EB%B0%8F-%EC%83%81%ED%83%9C-%EB%A6%AC%ED%94%84%EB%A0%88%EC%8B%9C-%EC%9A%94%EC%B2%AD)

---

### 채팅방 내 클라이언트 요청

[채팅방에 메세지 보내기](https://github.com/seunghx/Gings-Server/wiki/%EC%B1%84%ED%8C%85%EB%B0%A9%EC%97%90-%EB%A9%94%EC%84%B8%EC%A7%80-%EB%B3%B4%EB%82%B4%EA%B8%B0)

[메세지 확인]()


---

### GINGS PUSH NOTIFICATION
깅스 프로젝트에는 푸시 알림 기능이 있습니다. 이에 대한 개발을 하던 중 FCM을 사용할 경우 보다 구현이 편하고(해당 기술 사용경험이 있는 팀원들이 있어 더 그랬습니다.) FCM은 (현재 제가 아는 한 어플리케이션 레벨에서 사용하는)웹 소켓으로는 할 수 없는 - 어플리케이션이 종료되었을 때에도 PUSH 알림을 받을 수 있는 기능이 있어 FCM을 사용하는 것으로 변경하게 되었습니다. 

당시 작성하던 코드는 완성이 된 상태가 아니라 컴파일 될 수 없는 상황이어서 PUSH를 하기 위해 급하게 삭제하였었는데 이 부분을 commit 이력을 뒤져 복원하였습니다.

완성하지는 못했으나 가능한 한 유연하게 만들어보고자 노력해보았습니다.



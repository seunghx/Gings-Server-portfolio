# Gings server portfolio

### GINGS CHAT

깅스 프로젝트에는 채팅 기능이 있었습니다. 처음에는 별다른 어려움 없이 개발이 가능할 것이라고 예상하였습니다. 그러나 추가로 고려해야 할 사항이 생겼습니다. 후에 웹 브라우저에서도 깅스 서비스가 제공되어야 했기 때문입니다.

#### 메세지 저장
수많은 채팅 메세지를 서버에 저장하게되면 데이터 저장 비용이 상당할 것입니다. (서버의 데이터 저장 비용 문제는 일정 기간이 지난 메세지는 삭제하는 방식으로 조율해볼 수 있을 것 같습니다.) 
또한 클라이언트는 매번 채팅방(또는 채팅방 목록 화면)에 입장할 때마다 서버로부터 메세지들을 받아와야 할 것입니다.(서버에만 메세지가 저장될 경우)

이 문제를 해결하기 위해 클라이언트 기기(내부 스토리지)에 메세지를 저장하기로 하였습니다. 그러나 클라이언트 기기에만 메세지를 저장할 경우 즉 서버는 메세지를 저장하지 않을 경우 다른 문제가 발생할 수 있습니다.

안드로이드 앱, IOS 앱, 웹 브라우저 등 다수의 클라이언트가 있을 경우, 예를 들어 모바일 기기에 저장된 메세지(기록)를 브라우저에서는 볼 수 없기 때문입니다.(브라우저의 내부 스토리지에는 모바일로 대화한 메세지가 저장되어 있지 않을 것이기 때문) 

그래서 서버에도 메세지를 저장해 다른 기기(혹은 다른 클라이언트)에서 통신 했던 메세지 기록을 현재 클라이언트에서 볼 수 있도록 하였습니다. 이 과정을 동기화라고 하겠습니다. 

---

#### * latestReceivedMessage


> let latestReceivedMessage : 클라이언트가 가장 최근 서버로부터 받은 메세지 ID (per each chatting room) 


동기화를 위한 단순한 방법은 타기종 클라이언트에 새로 로그인 했을 경우 모든 채팅방 목록과 일정 수 만큼의 최근 메세지를 모두 서버로부터 받아오는 것입니다. 
그러나 위 방법은 채팅 관련 정보의 변경이 전혀 없는 경우에도(다른 클라이언트로 서비스를 이용하던 중 새로 추가 및 삭제된 채팅방도 없고 새로 받은 
메세지도 없는 경우) 많은 데이터를 서버로부터 전달받아야합니다. 

위와 같은 낭비적인 통신이 발생하지 않도록 현재 클라이언트 기기가 가장 최근에 서버로부터 받은 메세지의 id를(latestReceivedMessage) 내부 스토리지에 저장하게 하였습니다. 이 lastestReceivedMessage는 서버로부터 새 메세지가 올 때마다 새 메세지의 id로 값이 변경됩니다. 이때 클라이언트는 변경된 latestReceivedMessage를 서버에 전달하고 이를 전달받은 서버는 해당 채팅방에 대한 사용자의 latestReceivedMessage를(DB에 저장되어있음) 갱신합니다.

클라이언트는 서버와의 connection(로그인 후의 채팅을 위한 connection 및 네트워크 문제로 인한 reconnection)에 성공한 경우 각 채팅방의 latestReceivedMessage를 서버에 전달합니다. 서버는 전달받은 latestReceivedMessage를 DB에 저장된 latestReceivedMessage와 비교한 후
필요할 경우 최신 메세지들과 변경된 latestRecivedMessage를 클라이언트에 응답합니다. (이하 refresh 요청)

이와 동일한 방법으로, 서버는 추가 및 삭제된 채팅방 정보와 채팅방별로 추가 및 삭제된 유저 정보까지 refresh 요청에 대한 응답으로 클라이언트에 전달하여 동기화 가능하도록 하였습니다.

---
#### * lastReadMessage


> let lastReadMessage : 사용자가 가장 마지막으로 읽은 메세지 ID (per each chatting room)



많은 채팅 서비스를 보면 사용자가 특정 메세지를 읽었는지 읽지 않았는지에 대한 표시를 해줍니다. 

이 기능을 구현하기 위한 간단한 방법은 각 메세지 별로 특정 사용자가 이를 읽었는지 아닌지에 대한 정보를 저장하는 방법이 있겠습니다. 그러나 이 방법의 경우 한 채팅방만 해도 ***사용자 수 x 메세지 수*** 만큼의 레코드가 데이터베이스에 저장되어야 하므로 좋은 방법은 아니라고 생각했습니다.


대신 채팅방마다 가장 마지막에 읽은 메세지를 가리키는 정보를(이하 lastReadMessage) 클라이언트와 서버에 각각 저장하기로 하였습니다.
사용자가 채팅방에 입장하면 lastReadMessage는 latestReceivedMessage 값으로 변경됩니다. 
(latestReceivedMessage가 현재 클라이언트가 서버로부터 어디까지의 메세지를 받았는지에 사용되는 반면 lastReadMessage는 사용자가 어디까지 메세지를
읽었는지를 나타냅니다.)


lastReadMessage도 다른 정보와 마찬가지로 동기화가 필요한 부분입니다. 브라우저에서 읽음 표시된 메세지가 모바일 앱에서는 읽지 않음 처리되면 안될 것입니다. lastReadMessage에 대한 동기화를 위해 사용자가 메세지를 읽으면 클라이언트는 서버에 lastReadMessage를 전달하고 이를 전달받은 서버는 값을 갱신합니다. 후에 refresh 요청이 있을 때 클라이언트로부터 lastReadMessage를 받은 서버는 DB에 저장되어 있던 lastReadMessage를 비교하여 필요할 경우 갱신된 lastReadMessage를 전달합니다.


인터넷에 간단한 채팅 기능을 다루는 자료는 많았으나 보다 디테일한 상황까지 다루는 자료는 찾을 수 없었고 조언을 구할 멘토가 없어 어려움이 있었습니다. 기능을 축소하여 간단하게만 진행할까 생각도 했지만 하나의 기능을 구현하더라도 보다 완벽히 하고 싶었습니다. 물론 완벽하진 않지만 위의 과정을 고민해보며 좋은 경험이 되었다고 생각합니다.

---


### 한계 

1. **메세지 확인 기능(명이 메세지를 확인했는지)을 아직 구현못했다.**
 --> 현재 구현에서 위 기능을 추가하려면 고민해봐야 할 것이 많다. 
      -> 사용자가 각각의 메세지를 읽었는지를 저장하는 대신 lastReadMessage만 저장한 상황이기 때문. 
         (예 : 네트워크 상황 등의 이유로 읽음 처리 관련 응답이 여러번 도착할 경우)
 
2. **사용자가 어플리케이션에서 로그아웃하고 다른 계정으로 로그인해 채팅하는 경우를 고려하지 않았다는 점**
 (클라이언트 사이드에서 고민할 사항이긴 함)

3. **채팅방 유형(1:1, 그룹 채팅방)에 대한 처리(예 : 1:1 채팅의 경우 새로운 방이 생성되는 것을 방지해야함)를 위해 도메인을 변경할 필요가 있으며 기존 RDB를 그대로 사용하게 될 경우 필요시 채팅방 유형에 따라 테이블을 나눠야 할 수도 있으며(프로젝트 시간상 도메인 구조를 더 유연하게 변경하지는 못했다.) 채팅 메세지의 양이 엄청날 것이라는 점, 후에 서비스가 고도화 될 경우 메세지 타입도 여러가지가 될 것(스키마가 메세지 타입에 따라 다소 다를 수 있음)인데 이러한 점을 다 고려하였을 때 몽고DB와 같은 DOCUMENT 타입 NoSQL 사용이 더 좋았을 것이다. 메세지 타입과 채팅방 타입마다 RDB로 테이블을 나눠표현할 경우 채팅방 또는 메세지 목록을 취합하는 과정이 필요함. 메세지의 경우 시간 순에 맞게 정렬을하면 되므로 메세지 타입을 가리키는 슈퍼 클래스를 두고 이에 대한 리스트에서 시간 순에 맞게 정렬할 수는 있으나 그만큼 더 서버가 할일이 늘어나는셈이며 메세지를 저장할 때도 비교를 통해 메세지 타입에 따라 분기 시켜줘야한다.**

4. **아직 STOMP 프로토콜이 많이 이용되지 않은 만큼 클라이언트 라이브러리가 얼마 없었다. (특히 안드로이드의 경우 SPRING STOMP와 통신 가능한 웹소켓 기반 STOMP 클라이언트 라이브러리가 하나 밖에 없었으며 그마저도 문서화가 잘 되지 않았다.)** SPRING STOMP에서 SimpleBrokerMessageHandler와같은 메세지 브로커 동작을 하는 클래스를 이미 구현해놓았기 때문에 직접 세션에 대한 관리를 해줘야하는 WEB SOCKET에 비해(물론 TCP도) 구현이 편할 것이라고 생각하여 STOMP를 선택하였는데 돌이켜 생각해보면 클라이언트 지원 라이브러리가 만족스럽지 않아 그만큼 시간 낭비가 있던 것 같다. 기술을 선택함에 있어 이러한 요소도 중요한 요소가 될 수 있겠다.
 
---

## 채팅 API DOC
|프로토콜|ws|
|----|----|

---

### STOMP connect 요청 
|엔드포인트|설명|
| ------------ | ------------------ |
| /connect | Stomp connect end point |

#### 요청 STOMP header

|헤더명|값 설명|
|----|----|
|Authorization|Bearer tokenValue|

---
### 채팅방 외 클라이언트 요청
[채팅 관련 공지 채널 구독](https://github.com/seunghx/Gings-Server/wiki/%EC%B1%84%ED%8C%85-%EA%B3%B5%EC%A7%80-%EC%B1%84%EB%84%90-%EA%B5%AC%EB%8F%85)

[채팅방 생성](https://github.com/seunghx/Gings-Server/wiki/%EC%B1%84%ED%8C%85%EB%B0%A9-%EC%83%9D%EC%84%B1)

[채팅방 구독(입장)](https://github.com/seunghx/Gings-Server/wiki/%EC%B1%84%ED%8C%85%EB%B0%A9-%EA%B5%AC%EB%8F%85(%EC%9E%85%EC%9E%A5))

[리프레시 요청](https://github.com/seunghx/Gings-Server/wiki/%EC%B1%84%ED%8C%85%EB%B0%A9-%EB%AA%A9%EB%A1%9D-%EB%B0%8F-%EC%83%81%ED%83%9C-%EB%A6%AC%ED%94%84%EB%A0%88%EC%8B%9C-%EC%9A%94%EC%B2%AD)

---

### 채팅방 내 클라이언트 요청

[채팅방에 메세지 보내기](https://github.com/seunghx/Gings-Server/wiki/%EC%B1%84%ED%8C%85%EB%B0%A9%EC%97%90-%EB%A9%94%EC%84%B8%EC%A7%80-%EB%B3%B4%EB%82%B4%EA%B8%B0)

[메세지 확인]()


---

### GINGS PUSH NOTIFICATION
깅스 프로젝트에는 푸시 알림 기능이 있습니다. 이에 대한 개발을 하던 중 FCM을 사용할 경우 보다 구현이 편하고(해당 기술 사용경험이 있는 팀원들이 있어 더 그랬습니다.) FCM은 (현재 제가 아는 한 어플리케이션 레벨에서 사용하는)웹 소켓으로는 할 수 없는 - 어플리케이션이 종료되었을 때에도 PUSH 알림을 받을 수 있는 기능이 있어 FCM을 사용하는 것으로 변경하게 되었습니다. 

당시 작성하던 코드는 완성이 된 상태가 아니라 컴파일 될 수 없는 상황이어서 PUSH를 하기 위해 급하게 삭제하였었는데 이 부분을 commit 이력을 뒤져 복원하였습니다.

완성하지는 못했으나 가능한 한 유연하게 만들어보고자 노력해보았습니다.


